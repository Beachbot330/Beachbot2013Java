// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc330.Beachbot2013Java.subsystems;
import com.sun.squawk.util.MathUtils;
import org.usfirst.frc330.Beachbot2013Java.RobotMap;
import org.usfirst.frc330.Beachbot2013Java.commands.*;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc330.wpilibj.BeachbotPrefSendablePIDController;
import org.usfirst.frc330.Beachbot2013Java.Robot;
/*
 * $Log: Arm.java,v $
 * Revision 1.39  2013-03-31 05:38:39  jross
 * add shooter adjustment with operator thumbwheel
 *
 * Revision 1.38  2013-03-30 02:32:05  jross
 * make distances for actual, practice, red, and blue camera distances in vision table
 *
 * Revision 1.37  2013-03-29 04:36:50  jross
 * remove default command. arm moves with button 3
 *
 * Revision 1.36  2013-03-29 03:55:03  jross
 * create method to check vision and only move arm if vision is within min and max distance
 *
 * Revision 1.35  2013-03-27 04:15:38  jross
 * make a bigger deadband for the arm
 *
 * Revision 1.34  2013-03-25 05:12:56  jross
 * add method to use vision table
 *
 * Revision 1.33  2013-03-24 17:55:51  jross
 * create method for putting the arm past the climbing position
 *
 * Revision 1.32  2013-03-20 07:16:33  dstation
 * Add Blocker
 *
 * Revision 1.31  2013-03-20 05:07:49  dstation
 * robotbuilder update
 *
 * Revision 1.30  2013-03-20 04:48:06  dstation
 * Added method to toggle climb ten
 *
 * Revision 1.29  2013-03-18 00:38:36  echan
 * removed arm brake solenoid
 *
 * Revision 1.28  2013-03-17 18:17:45  jross
 * use fixed angle for shooter for simplicity
 *
 * Revision 1.27  2013-03-17 01:57:22  jdavid
 * Added pickup sensor
 *
 * Revision 1.26  2013-03-16 22:46:35  jross
 * fix manual arm so it turns off when joystick 0
 *
 * Revision 1.25  2013-03-15 04:23:50  echan
 * made the arm set point low to use the lookup table
 *
 * Revision 1.24  2013-03-15 03:13:53  echan
 * Removed holdArmOff/On and the brake arm solenoid
 *
 * Revision 1.23  2013-03-15 02:53:28  echan
 * Removed the todo
 *
 * Revision 1.22  2013-03-15 02:51:28  echan
 * added cvs log comments
 *
 */
 
/**
 *
 */
public class Arm extends Subsystem implements PIDSource, PIDOutput{
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController armSpeedController = RobotMap.armArmSpeedController;
    AnalogChannel potentiometer = RobotMap.armPotentiometer;
    DoubleSolenoid climberSolenoid = RobotMap.armClimberSolenoid;
    DoubleSolenoid blockerSolenoid = RobotMap.armBlockerSolenoid;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private BeachbotPrefSendablePIDController armPID;
//    private PIDController armPID;
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    private static final String PREF_Arm_ArmPickupTimeToWait = "ArmPickupTimeToWait";
    private static final String PREF_Arm_ArmShootingTimeToWait = "ArmShootingTimeToWait";
    private static final String PREF_Arm_ArmPositionLowerLimit = "ArmPositionLowerLimit";
    private static final String PREF_Arm_ArmPositionUpperLimit = "ArmPositionUpperLimit";
    
    public Arm(){
        armPID = new BeachbotPrefSendablePIDController(0,0,0,this,this, "armPID");
//        armPID = new PIDController(0,0,0,this,this);
        armPID.setAbsoluteTolerance(0.1);
        Preferences.getInstance().putDouble("ArmAbsoluteTolerance", 0.1);
        SmartDashboard.putData("ArmPID", armPID);
    }
    
    public double getArmZero()
    {
        String name;
        
        if (Robot.isPracticerobot())
            name = "PracticeArmPositionZero";
        else
            name = "CompetitionArmPositionZero";
        if (!Preferences.getInstance().containsKey(name))
        {
            Preferences.getInstance().putDouble(name, 0.0);
            Preferences.getInstance().save();
        }
        return Preferences.getInstance().getDouble(name, 0.0);
    }
    /**
     * Set the arm zero at the current position of the arm.
     */
    public void setArmZero()
    {        
        String name;
        
        if (Robot.isPracticerobot())
            name = "PracticeArmPositionZero";
        else
            name = "CompetitionArmPositionZero";
        
        Preferences.getInstance().putDouble(name, potentiometer.getAverageVoltage());
        Preferences.getInstance().save();
    }
    public double getArmHighShooting() {
        if (!Preferences.getInstance().containsKey("armSetpointHighShooting"))
        {
            Preferences.getInstance().putDouble("armSetpointHighShooting", 1.5);
            Preferences.getInstance().save();
        }
        return Preferences.getInstance().getDouble("armSetpointHighShooting", 1.5);
    }
    public double getArmLowShooting() {
        if (!Preferences.getInstance().containsKey("armSetpointLowShooting"))
        {
            Preferences.getInstance().putDouble("armSetpointLowShooting", .1);
            Preferences.getInstance().save();
        }
        return Preferences.getInstance().getDouble("armSetpointLowShooting", .1);
    }
    public double getArmLowPickup() {
        if (!Preferences.getInstance().containsKey("armSetpointLowPickup"))
        {
            Preferences.getInstance().putDouble("armSetpointLowPickup", .1);
            Preferences.getInstance().save();
        }
        return Preferences.getInstance().getDouble("armSetpointLowPickup", .1);
    }
    public double getArmClimbing() {
        if (!Preferences.getInstance().containsKey("armSetpointClimbing"))
        {
            Preferences.getInstance().putDouble("armSetpointClimbing", 2);
            Preferences.getInstance().save();
        }
        return Preferences.getInstance().getDouble("armSetpointClimbing", 2);
    }
    
    public void manualArm() {
        double armCommand = Robot.oi.operatorJoystick.getY();
        if (Math.abs(armCommand) > 0.10 && armPID.isEnable())
        {
            armPID.disable();
            set(armCommand);
        }
        else if (!armPID.isEnable() && Math.abs(armCommand) > 0.10)
        {
            set(armCommand);
        }
        else if (!armPID.isEnable())
        {
            set(0);
        }
    }
    
    public double getArmPosition()
    {
        return potentiometer.getAverageVoltage()-getArmZero();
    }
    
    public void armSetPoint(double setpoint) {
        armPID.setSetpoint(setpoint);
    }
    
    public void armSetPointHighShooting() {
        armSetPoint(getArmHighShooting());
    }
    
    public void armSetPointLowShooting() {
//        armSetPoint(Robot.vision.armLookupTable(Robot.vision.getDistance()));
        armSetPoint(getArmLowShooting());
    }
    
    public void armSetPointLowVision()
    {
        armSetPoint(Robot.vision.armLookupTable(Robot.vision.getDistance()));
    }
    double prevDistance;
    double prevShooterAdjust;
    double filteredDistance;
    
    public void initFilteredDistance()
    {
        filteredDistance = Robot.vision.getDistance();
        filteredDistance = MathUtils.round(filteredDistance*10)/10.0;
    }
    public void armSetPointLowCheckVision()
    {
        double distance;
        double shooterAdjust;
        double setpoint;
        
        distance = Robot.vision.getDistance();
        distance = MathUtils.round(distance*10)/10.0;
        
        if (distance > 0 && !Double.isInfinite(distance) && !Double.isNaN(distance))
        {
            distance = filteredDistance*.75 + distance*.25;
        }
            else 
        {
            distance = filteredDistance;
        }
        
        shooterAdjust = Robot.oi.getOperatorJoystick().getRawAxis(3);
        shooterAdjust *= -(4.0/100.0);
        
        if (shooterAdjust != prevShooterAdjust)
        {
            SmartDashboard.putNumber("ShooterAdjust", shooterAdjust);
        }       
        setpoint = Robot.vision.armLookupTable(distance)+shooterAdjust;
        if (setpoint != Robot.arm.getSetpoint())
        {
            armSetPoint(setpoint);
        }
        prevDistance = distance;
        prevShooterAdjust = shooterAdjust;
        filteredDistance = distance;
    }
    
    public void armSetPointLowPickup() {
        armSetPoint(getArmLowPickup());
    }
    
    public void armSetPointClimbing() {
        armSetPoint(getArmClimbing());
    }
    
    public void armSetPointPastClimbing() {
        armSetPoint(getArmClimbing()+0.10);
    }
        
    public double armWaitPickup() {
        double armpickuptimetowait = 0.5;
        if (Preferences.getInstance().containsKey(PREF_Arm_ArmPickupTimeToWait))
        {
            armpickuptimetowait = Preferences.getInstance().getDouble(
                            PREF_Arm_ArmPickupTimeToWait,armpickuptimetowait);
        } else 
        {
            Preferences.getInstance().putDouble(PREF_Arm_ArmPickupTimeToWait, 
                                                armpickuptimetowait);
            Preferences.getInstance().save();
        }
        return armpickuptimetowait;
    }
    
    public double armWaitShooting() {
        double armshootingtimetowait = 0.5;
        if (Preferences.getInstance().containsKey(PREF_Arm_ArmShootingTimeToWait))
        {
            armshootingtimetowait = Preferences.getInstance().getDouble(
                            PREF_Arm_ArmShootingTimeToWait,armshootingtimetowait);
        } else 
        {
            Preferences.getInstance().putDouble(PREF_Arm_ArmShootingTimeToWait, 
                                                armshootingtimetowait);
            Preferences.getInstance().save();
        }
        return armshootingtimetowait;
    }
    
    public double armLowerLimit() {
        double armpositionlowerlimit = 0;
        if (Preferences.getInstance().containsKey(PREF_Arm_ArmPositionLowerLimit))
        {
            armpositionlowerlimit = Preferences.getInstance().getDouble(
                            PREF_Arm_ArmPositionLowerLimit,armpositionlowerlimit);
        } else 
        {
            Preferences.getInstance().putDouble(PREF_Arm_ArmPositionLowerLimit, 
                                                armpositionlowerlimit);
            Preferences.getInstance().save();
        }
        return armpositionlowerlimit;
    }
    
    public double armUpperLimit() {
        double armpositionupperlimit = 2;
        if (Preferences.getInstance().containsKey(PREF_Arm_ArmPositionUpperLimit))
        {
            armpositionupperlimit = Preferences.getInstance().getDouble(
                            PREF_Arm_ArmPositionUpperLimit,armpositionupperlimit);
        } else 
        {
            Preferences.getInstance().putDouble(PREF_Arm_ArmPositionUpperLimit, 
                                                armpositionupperlimit);
            Preferences.getInstance().save();
        }
        return armpositionupperlimit;
    }
    
    public synchronized double getSetpoint() {
        return armPID.getSetpoint();
    }
    public synchronized boolean onTarget() {
        return armPID.onTarget();
    }
    public synchronized boolean isEnable() {
        return armPID.isEnable();
    }
    public synchronized void enable() {
        armPID.enable();
    }
    public synchronized void disable() {
        armPID.disable();
    }
    public double pidGet() {
        return getArmPosition();
    }
    public void pidWrite(double output) {
        set(output);
    }
    
    //TODO set different high limit whether pickup is up or down
    public void set(double output){
        if (output > 0 && getArmPosition() > armUpperLimit())
            armSpeedController.set(0);
        else if (output < 0 && getArmPosition() < armLowerLimit())
            armSpeedController.set(0);
        else
            armSpeedController.set(output);
    }
    
    public void toggleClimbTen() {
    if(climberSolenoid.get() == DoubleSolenoid.Value.kReverse)
        climberSolenoid.set(DoubleSolenoid.Value.kForward);
    else
        climberSolenoid.set(DoubleSolenoid.Value.kReverse);
    }
    
    public void toggleBlocker() {
    if(blockerSolenoid.get() == DoubleSolenoid.Value.kReverse)
        blockerSolenoid.set(DoubleSolenoid.Value.kForward);
    else
        blockerSolenoid.set(DoubleSolenoid.Value.kReverse);
    }
}
